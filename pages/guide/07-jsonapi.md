---
layout: guide
group: guide
title: Json API
---

In some scenarios, JSON-API does not define how an implementation should behave.  Elide also may not implement all optional features of the
JSON-API specification.  The following sections clarify Elide's behavior with respect to undefined or optional aspects of JSON-API.

## Hierarchical URLs

Elide generally follows the [JSON-API recommendations](http://jsonapi.org/recommendations/) for URL design.

There are a few caveats given that Elide allows developers control over how entities are exposed:

1. Some entities may only be reached through a relationship to another entity.  Not every entity is _rootable_.
1. The root path segment of URLs are by default the name of the class (lowercase).  This can be overridden.
1. Elide allows relationships to be nested arbitrarily deep in URLs.
1. Elide currently requires all individual entities to be addressed by ID within a URL.  For example, consider a model with an article with a singular author which has a singular address.   While unambiguous, the following is *not* allowed: `/articles/1/author/address`.  Instead, the author must be fully qualified by ID: `/articles/1/author/34/address`

## Filters

Elide supports filters that are similar to the [JSON-API recommendations](http://jsonapi.org/recommendations/).
However, it extends them to support additional filter operator types and compound documents.

Filters are only supported on attributes with simple, primitive types.

### Rough BNF Syntax

Filters will be passed as query parameters in the URL with the following BNF syntax:

```
<QUERY> ::= 
     "filter" "[" <TYPE> "." <ATTRIBUTE> "]" "=" <VALUES>
   | "filter" "[" <TYPE> "." <ATTRIBUTE> "]" "[in]" "=" <VALUES> 
   | "filter" "[" <TYPE> "." <ATTRIBUTE> "]" "[not"” "=" <VALUES> 
   | "filter" "[" <TYPE> "." <ATTRIBUTE> "]" "[prefix]" "=" <VALUE> 
   | "filter" "[" <TYPE> "." <ATTRIBUTE> "]" "[postfix]" "=" <VALUE> 
   | "filter" "[" <TYPE> "." <ATTRIBUTE> "]" "[infix]" "=" <VALUE> 
   | "filter" "[" <TYPE> "." <ATTRIBUTE> "]" "[isnull]"
   | "filter" "[" <TYPE> "." <ATTRIBUTE> "]" "[notnull]"

<ATTRIBUTE> ::= <TERM>
<TYPE> ::= <TERM>

<VALUE> ::= <URL_ENCODED_TERM> 
<VALUES> ::= <URL_ENCODED_TERM> | <URL_ENCODED_TERM> “,” <VALUES>
```

### Values
Values are simply a comma separated list of URL encoded strings.

### Type Coercion
Values are type coerced into the appropriate primitive data type for the attribute filter.

### Multiple Filters
When multiple filters are present for the same type, the filters are a logical ‘and’ for any collection with
that type.   Filters are type independent: any filters for type 'A' do *not* modify the results 
returned for a collection of type 'B'.

### Operators

Elide supports the following operators.  When an operator is not specified, Elide uses the `in` operator.

1. `in` : Evaluates to true if the attribute exactly matches any of the values in the list.
1. `not` : Evaluates to true if the attribute does not match any of the values in the list.
1. `prefix` : Similar to SQL `like 'value%`.
1. `postfix` : Similar to SQL `like '%value`.
1. `infix` : Similar to SQL `like '%value%`.
1. `isnull` : Evaluates to true if the attribute is null
1. `notnull` : Evaluates to true if the attribute is not null

### Examples

Return all the comments associated with article 1 whose name is 'Elide is great'.

`/articles/1/comments?filter[comment.title]=Elide%20is%20great` 

The same as the prior example except the operator is explicit.

`/articles/1/comments?filter[comment.title][in]=Elide%20is%20great` 

The same as prior except include all the comment votes but only those which were voted up.

`/articles/1/comments?include=comments.votes&filter[comment.title][in]=Elide%20is%20great&filter[vote.up]=true` 

Return all comments where the title is not null:

`/articles/1/comments?filter[comment.title][notnull]`

Return all comments posted by anonymous people:

`/articles/1/comments?filter[comment.author][isnull]`

## Model Identifiers

Elide supports three mechanisms by which a newly created entity is assigned an ID:

1. The ID is assigned by the client and saved in the data store.
1. The client doesn't provide an ID and the data store generates one.
1. The client provides an ID which is replaced by one generated by the data store.  When using the patch extension, the client
must provide an ID to identify objects which are both created and added to collections in other objects.  However, in some instances
the server should have ultimate control over the ID that is assigned.  

### Data Store Generated IDs

Elide looks for the JPA `GeneratedValue` annotation to disambiguate whether or not
the data store generates an ID for a given data model.   If the client also generated 
an ID during the object creation request, the data store ID overrides the client value.

### Matching newly created objects to IDs

When using the patch extension, Elide always returns object entity bodies (containing newly assigned IDs) in 
the order in which they were created.  The client can use this order to map the object created to its ID.

### ID types

ID fields must be `Serializable` objects.   Elide does not require IDs to be UUIDs (a divergence from JSON-API).
