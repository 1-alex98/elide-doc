---
layout: guide
group: guide
title: Json API
---

# JSON-API 

[JSON-API](jsonapi.org) is a specification for building REST APIs for CRUD (create, read, update, and delete) operations.  
Similar to graphQL: 
*  It allows the client to control what is returned in the response payload.  
*  It also offered an API extension (the _patch extension_) that allowed multiple mutations to the graph to occur in a single request.

Unlike graphQL, it is more structured - laying out how to perform common API operations.  

Also unlike graphQL, it has no standardized API introspection.  However, Elide adds this capability to any service by exporting 
an [Open API Initiative](www.openapis.org) document (formerly known as [Swagger](swagger.io)).

The [json-api specification](http://jsonapi.org/format/) is the best reference for understanding JSON-API.  The following sections describe Elide additions
for filtering, pagination, sorting, and swagger.

## Hierarchical URLs

Elide generally follows the [JSON-API recommendations](http://jsonapi.org/recommendations/) for URL design.

There are a few caveats given that Elide allows developers control over how entities are exposed:

1. Some entities may only be reached through a relationship to another entity.  Not every entity is _rootable_.
1. The root path segment of URLs are by default the name of the class (lowercase).  This can be overridden.
1. Elide allows relationships to be nested arbitrarily deep in URLs.
1. Elide currently requires all individual entities to be addressed by ID within a URL.  For example, consider a model with an 
article with a singular author which has a singular address.   While unambiguous, the following is *not* allowed: `/articles/1/author/address`.  
Instead, the author must be fully qualified by ID: `/articles/1/author/34/address`

## Model Identifiers

Elide supports three mechanisms by which a newly created entity is assigned an ID:

1. The ID is assigned by the client and saved in the data store.
1. The client doesn't provide an ID and the data store generates one.
1. The client provides an ID which is replaced by one generated by the data store.  When using _UPSERT_, the client
must provide an ID to identify objects which are both created and added to collections in other objects.  However, in some instances
the server should have ultimate control over the ID that is assigned.  

Elide looks for the JPA `GeneratedValue` annotation to disambiguate whether or not
the data store generates an ID for a given data model.   If the client also generated 
an ID during the object creation request, the data store ID overrides the client value.

### Matching newly created objects to IDs

When using _UPSERT_, Elide returns object entity bodies (containing newly assigned IDs) in 
the order in which they were created - assuming all the entities were newly created (and not mixed
with entity updates in the request).  The client can use this order to map the object created to its ID.


## Filtering

JSON-API 1.0 is agnostic to filtering strategies.  The only recommendation is that servers and clients _should_
prefix filtering query parameters with the word 'filter'.

Elide supports multiple filter dialects and the ability to add new ones to meet the needs of developers or to evolve
the platform should JSON-API standardize them.

### Supported Dialects

Elide supports two primary dialects - [RSQL](#rsql) and [basic](#basic).

### RSQL

[RSQL](https://github.com/jirutka/rsql-parser) is a query language that allows conjunction (and), disjunction (or), and parenthetic grouping
of boolean expressions.  It is a superset of the [FIQL language](https://tools.ietf.org/html/draft-nottingham-atompub-fiql-00).

Because RSQL is a superset of FIQL, FIQL queries should be properly parsed.
RSQL primarily adds more friendly lexer tokens to FIQL for conjunction and disjunction: 'and' instead of ';' and 'or' instead of ','.
RSQL also adds a richer set of operators.

#### RSQL Filter Syntax

To specify _disjoint filters_, the filter query parameters look like `filter[TYPE]` where 'TYPE' is the name of the data model/entity.  
Any number of filter parameters can be specified provided the 'TYPE' is different for each parameter.

The value of any query parameter is a RSQL expression composed of predicates.  Each predicate contains an attribute of the data model,
an operator, and zero or more comparison values.

#### RSQL Filter Examples

Return all the books written by author '1' with the genre exactly equal to 'Science Fiction':

`/author/1/book?filter[book]=genre=='Science Fiction'`

Return all the books written by author '1' with the genre exactly equal to 'Science Fiction' _and_ the title starts with 'The':

`/author/1/book?filter[book]=genre=='Science Fiction';title==The*`

Return all the books written by author '1' with the publication date greater than a certain time _or_ the genre _not_ 'Literary Fiction'
or 'Science Fiction':

`/author/1/book?filter[book]=publishDate>1454638927411,genre=out=('Literary Fiction','Science Fiction')`

Return all the books whose title contains 'Foo'.  Include all the authors of those books whose name does not equal 'Orson Scott Card':

`/book?include=authors&filter[book]=title==*Foo*&filter[author]=name!='Orson Scott Card'`

#### RSQL Operators

The following RSQL operators are supported:

* `=in=` : Evaluates to true if the attribute exactly matches any of the values in the list.
* `=out=` : Evaluates to true if the attribute does not match any of the values in the list.
* `==ABC*` : Similar to SQL `like 'ABC%`.
* `==*ABC` : Similar to SQL `like '%ABC`.
* `==*ABC*` : Similar to SQL `like '%ABC%`.
* `=isnull=true` : Evaluates to true if the attribute is null
* `=isnull=false` : Evaluates to true if the attribute is not null
* `=lt=` : Evaluates to true if the attribute is less than the value.
* `=gt=` : Evaluates to true if the attribute is greater than the value.
* `=le=` : Evaluates to true if the attribute is less than or equal to the value.
* `=ge=` : Evaluates to true if the attribute is greater than or equal to the value.

### Basic 

Elide supports filters that are similar to the [JSON-API recommendations](http://jsonapi.org/recommendations/).
However, it extends them to support additional filter operator types and compound documents.
Filters are only supported on attributes with simple, primitive types.

#### Basic Filter Syntax

Basic filtering has the following _rough_ BNF syntax for the query parameter and value:

```
<QUERY> ::= 
     "filter" "[" <TYPE> "." <ATTRIBUTE> "]" "=" <VALUES>
   | "filter" "[" <TYPE> "." <ATTRIBUTE> "]" "[in]" "=" <VALUES> 
   | "filter" "[" <TYPE> "." <ATTRIBUTE> "]" "[not]" "=" <VALUES> 
   | "filter" "[" <TYPE> "." <ATTRIBUTE> "]" "[prefix]" "=" <VALUE> 
   | "filter" "[" <TYPE> "." <ATTRIBUTE> "]" "[postfix]" "=" <VALUE> 
   | "filter" "[" <TYPE> "." <ATTRIBUTE> "]" "[infix]" "=" <VALUE> 
   | "filter" "[" <TYPE> "." <ATTRIBUTE> "]" "[isnull]"
   | "filter" "[" <TYPE> "." <ATTRIBUTE> "]" "[notnull]"

<ATTRIBUTE> ::= <TERM>
<TYPE> ::= <TERM>

<VALUE> ::= <URL_ENCODED_TERM> 
<VALUES> ::= <URL_ENCODED_TERM> | <URL_ENCODED_TERM> “,” <VALUES>
```

#### Basic Operators
Elide supports the following operators.  When an operator is not specified, Elide basic uses the `in` operator.

* `in` : Evaluates to true if the attribute exactly matches any of the values in the list.
* `not` : Evaluates to true if the attribute does not match any of the values in the list.
* `prefix` : Similar to SQL `like 'value%`.
* `postfix` : Similar to SQL `like '%value`.
* `infix` : Similar to SQL `like '%value%`.
* `isnull` : Evaluates to true if the attribute is null
* `notnull` : Evaluates to true if the attribute is not null
* `lt` : Evaluates to true if the attribute is less than the value.
* `gt` : Evaluates to true if the attribute is greater than the value.
* `le` : Evaluates to true if the attribute is less than or equal to the value.
* `ge` : Evaluates to true if the attribute is greater than or equal to the value.

#### Values
Values are simply a comma separated list of URL encoded strings.

#### Type Coercion
Values are type coerced into the appropriate primitive data type for the attribute filter.

#### Multiple Filters
When multiple filters are present for the same type, the filters are a logical ‘and’ for any collection with
that type.   Filters are type independent: any filters for type 'A' do *not* modify the results 
returned for a collection of type 'B'.

#### Basic Filter Examples

Return all the books written by author '1' with the genre exactly equal to 'Science Fiction':

`/author/1/book?filter[book.genre]=Science%20Fiction`

Return all the books written by author '1' with the genre exactly equal to 'Science Fiction' _and_ the title starts with 'The':

`/author/1/book?filter[book.genre]=Science%20Fiction&filter[book.title][prefix]=The`

Return all the books written by author '1' with the publication date greater than a certain time _and_ the genre _not_ 'Literary Fiction'
or 'Science Fiction':

`/author/1/book?filter[book.publishDate][gt]=1454638927411&filter[book.genre][not]=Literary%20Fiction,Science%20Fiction`

Return all the books whose title contains 'Foo'.  Include all the authors of those books whose name does not equal 'Orson Scott Card':

`/book?include=authors&filter[book.title][infix]=Foo&filter[author.name][not]=Orson%20Scott%20Card`

## Pagination

Elide supports:
1. Paginating a collection by row offset and limit.
2. Paginating a collection by page size and number of pages.
3. Returning the total size of a collection visible to the given user.
4. Returning a _meta_ block in the JSON-API response body containing metadata about the collection.
5. A simple way to control: 
  * the availability of metadata 
  * the number of records that can be paginated

### Syntax
Elide allows pagination of the primary collection being returned in the response via the _page_ query parameter.

The _rough_ BNF syntax for the _page_ query parameter is:
```
<QUERY> ::= 
     "page" "[" "size" "]" "=" <INTEGER>
   | "page" "[" "number" "]" "=" <INTEGER>
   | "page" "[" "limit" "]" "=" <INTEGER>
   | "page" "[" "offset" "]" "=" <INTEGER>
   | "page" "[" "totals" "]"
```

Legal combinations of the _page_ query params include:
1. size
1. number
1. size & number
1. size & number & totals
1. offset
1. limit
1. offset & limit
1. offset & limit & totals

### Meta Block
Whenever a _page_ query parameter is specified, Elide will return a _meta_ block in the
JSON-API response that contains:
1. The page _number_
2. The page size or _limit_
3. The total number of pages (_totalPages_) in the collection
4. The total number of records (_totalRecords_) in the collection.

The values for _totalPages_ and _totalRecords_ are only returned if the _page[totals]_ 
parameter was specified in the query.

```
"meta": {
  "page": {
    "number":1,
    "totalRecords":20,
    "limit":2,"
    "totalPages":10
   }
}
```

## Sorting

Elide supports:
1.  Sorting a collection by any attribute of the collection's type.
2.  Sorting a collection by multiple attributes at the same time in either ascending or descending order.
3.  Sorting a collection by any attribute of a to-one relationship of the collection's type.  Multiple relationships can be traversed provided the path 
from the collection to the sorting attribute is entirely through to-one relationships.

### Syntax
Elide allows sorting of the primary collection being returned in the response via the _sort_ query parameter.

The _rough_ BNF syntax for the _sort_ query parameter is:
```
<QUERY> ::= "sort" "=" <LIST_OF_SORT_SPECS>

<LIST_OF_SORT_SPECS> = <SORT_SPEC> | <SORT_SPEC> "," <LIST_OF_SORT_SPECS>

<SORT_SPEC> ::= "+|-"? <PATH_TO_ATTRIBUTE>

<PATH_TO_ATTRIBUTE> ::= <RELATIONSHIP> <PATH_TO_ATTRIBUTE> | <ATTRIBUTE>

<RELATIONSHIP> ::= <TERM> "."

<ATTRIBUTE> ::= <TERM>
```

### Sort By ID

The keyword _id_ can be used to sort by whatever field a given entity uses as its identifier.

## Swagger

Swagger documents can be highly customized.  As a result, they are not enabled by default and instead must be 
initialized through code.  The steps to do this are documented [here]({{site.baseurl}}/pages/guide/13-swagger.html).
